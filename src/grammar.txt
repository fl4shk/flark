program:
	(
		package
		| module
	)*
	;

header_if:
	TokKwIf '(' expr ')'
	;
header_for:
	TokKwFor '(' ident : expr ')'
	;

header_generate_if:
	TokKwGenerate header_if:
	;
header_else_generate_if:
	TokKwElse header_generate_if
	;
header_else_generate:
	TokKwElse TokKwGenerate
	;
header_generate_for:
	TokKwGenerate ident? header_for
	;


package:
	TokKwPackage ident
		scope_package
	;

scope_package:
	'{'
		(
			generate_package
			| package
			| module
			| const
			| using
			| decl_callable
			| decl_cstm_type
		)*
	'}'
	;


generate_package:
	generate_package_if
	| generate_package_for
	;
generate_package_if:
	header_generate_if scope_package
	(header_else_generate_if scope_package)*
	(header_else_generate scope_package)?
	;
generate_package_for:
	header_generate_for scope_package
	;


callable_member_prefix:
	// Handled by lookahead
	// TokKwConst, TokKwVirtual, TokKwStatic
	;

suffix_module_proc:
	param_list? arg_list
		scope_module_proc

proc:
	TokKwProc (ident | TokKwPort | const_str)
		suffix_module_proc
	;
module:
	TokKwModule ident
		suffix_module_proc
	;


scope_module_proc:
	'{'
		(
			generate_module_proc
			| const
			| var
			| using
			| decl_callable
			| decl_cstm_type
			| hardware_block
		)*
	'}'
	;

generate_module_proc:
	generate_module_proc_if
	| generate_module_proc_for
	;
generate_module_proc_if:
	header_generate_if scope_module_proc
	(header_else_generate_if scope_module_proc)*
	(header_else_generate scope_module_proc)?
	;
generate_module_proc_for:
	header_generate_for scope_module_proc
	;

decl_callable:
	func
	| task
	| proc
	;

suffix_func_task:
	param_list? arg_list
		scope_behav
	;

func:
	TokKwFunc typename
		suffix_behav
	;
task:
	TokKwTask
		suffix_behav
	;

scope_behav:
	'{'
		(
			generate_behav
			| const
			| var
			| using
			| stmt_assign
			| stmt_if
			| stmt_for
			| stmt_while
			| ident_etc
			| decl_cstm_type
		)*
	'}'
	;


generate_behav:
	generate_behav_if
	| generate_behav_for
	;
generate_behav_if:
	header_generate_if scope_behav
	(header_else_generate_if scope_behav)*
	(header_else_generate scope_behav)?
	;
generate_behav_for:
	header_generate_for scope_behav
	;


decl_cstm_type:
	class
	| enum
	| union
	;

class:
	TokKwPacked? TokKwClass ident param_list?
		extends?
		scope_class
	;
extends:
	TokKwVirtual? TokKwExtends typename
	;

scope_class:
	'{'
		(
			member_access_label?
			(callable_member_prefix? decl_callable)
			| 
		)*
	'}'
	;


// Top-level contents of a `module` or a `proc`.
hardware_block:
	cont_assign
	| initial
	| always_comb
	| always_blk
	| always_ff

	// Inside a `proc`, this is still valid.  This means that `module`s can
	// be instantiated inside of `class`es' `proc`s.
	| inst

	// This needs to be a proc call, but that's a semantic analysis
	// problem.
	| ident_etc
	;


param_list:
	'['
		sub_param_list
		(',' sub_param_list)*
		(',')?
	']'
	;

param_sublist:
	(pararg_type_sublist
	| param_module_sublist
	| pararg_var_sublist)
	(',' param_sublist)?
	(',')?
	;

arg_list:
	'('
		(arg_sublist
		(',' arg_sublist)*)?
		(',')?
	')'
	;

arg_sublist:
	(arg_port_sublist
	| pararg_type_sublist)
	(',' arg_sublist)?
	(',')?
	;

arg_port_sublist:
	(TokKwInput
	| TokKwOutput
	| TokKwBidir)
	pararg_var_sublist
	;

pararg_var_sublist:
	typename
	ident_terminal ('=' expr)?
	(',' ident_terminal ('=' expr)?)*
	;

pararg_type_sublist:
	TokKwType
	pararg_ident_equals_typename_sublist
	;

param_module_sublist:
	TokKwModule
	pararg_ident_equals_typename_sublist
	;

pararg_ident_equals_typename_sublist:
	ident ('=' typename)?
	(',' ident ('=' typename)?)*
	;

param_inst_list:
	'['
		(
			pos_pararg_inst_list
			| named_pararg_inst_list
		)?
		(',')?
	']'
	;

pos_pararg_inst_list:
	expr
	(',' expr)*
	;
named_pararg_inst_list:
	ident '=' expr
	(',' ident '=' expr)*
	;


stmt_while:
	TokKwWhile '(' expr ')'
	;


typename:
	param_possible_typename
	| no_param_possible_typename
	;

param_possible_typename:
	(ident_etc
		| TokKwUwire | TokKwSwire
		| TokKwUbit | TokKwSbit)
		param_inst_list
	;

no_param_possible_typename:
	TokKwVoid | TokKwAuto
	| TokUbyte | TokSbyte
	| TokUshortint | TokSshortint
	| TokUint | TokSint
	| TokUlongint | TokSlongint
	;

expr:
	inner_expr
	| expr_logical
	;
inner_expr:
	expr_logical TokOpLogical expr
	;

expr_logical:
	inner_expr_logical
	| expr_compare
	;
inner_expr_logical:
	expr_compare TokOpCompare expr_logical
	;

expr_compare:
	inner_expr_compare
	| expr_add_sub
	;
inner_expr_compare:
	expr_add_sub TokOpPlusMinus expr_compare
	;

expr_add_sub:
	inner_expr_add_sub
	| expr_mul_div_mod_etc
	;
inner_expr_add_sub:
	expr_mul_div_mod_etc TokOpMulDivModEtc expr_add_sub
	;

expr_mul_div_mod_etc:
	inner_expr_mul_div_mod_etc
	| '(' expr ')'
	| dollar_global_clock
	| dollar_pow_expr
	| ident_etc
	| num_expr
	| const_str
	;

inner_expr_mul_div_mod_etc:
	TokOpUnary expr
	;

dollar_global_clock:
	TokKwDollarGlobalClock
	;

dollar_pow_expr:
	TokKwDollarPow '(' expr ',' expr ')'
	;
const_str:
	TokConstStr
	;
typeof:
	TokKwTypeof '(' expr | typename ')'
	;


ident_etc:
	ident_etc_pre_dollar_func
	| ident_etc_post_dollar_func
	| inner_ident_etc
	;
ident_etc_pre_dollar_func:
	TokKwDollarFuncOfOne '(' ident_etc ')'
	;
ident_etc_post_dollar_func:
	inner_ident_etc TokKwDollarFuncOfOne
	;

inner_ident_etc:
	ident_terminal
	| ident_member_access
	| ident_call
	| ident_no_param_overloaded_call
	| ident_param_overloaded_call
	;

ident_terminal:
	ident_bracket
	| ident
	;

ident_member_access:
	ident_terminal '.' inner_ident_etc
	;
ident:
	TokIdent
	;

ident_bracket:
	ident ('[' expr ']')+
	;

ident_call:
	ident param_inst_list? arg_inst_list
	;

ident_no_param_overloaded_call:
	ident_terminal arg_inst_list
	;
ident_param_overloaded_call:
	ident_terminal '.' param_inst_list arg_inst_list
	;

