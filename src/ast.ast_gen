Program, List:
Package:
	child ident, scope;
ScopePackage, List:
Module:
	child ident, param_list, port_list, scope;
ScopeModproc, List:
ParamArgTypeSublist:
	initvar bool _param_pack;
	child ident_term_equals_extra_list;
ArgPortSublist:
	initvar string _port_dir;
	child param_arg_var_sublist;
ParamArgVarSublist:
	initvar bool _param_pack;
	child the_typename, ident_term_equals_extra_list;



// Modules are not types, but they can be used generically.
ParamModuleSublist:
	child ident_term_equals_extra_list;

// List of ParamArgVarSublist's or ParamModuleList's
ParamList, List:
ArgList, List:


LeftRightBase:
	child left, right;

// Example:  `i_a_arr[ARR_SIZE]`
// The list is of brackets.  Example of multiple brackets:  `i_a_arr[2][3]`
IdentTerminal, List:
	child ident;

// This represents the `.`, indicating a scope.
IdentMemberAccess:
IdentScopeAccess:

// This is either an expression or a statement.  It can only be an
// expression for non-`void` `func`tions.  It is part of an IdentEtc.
Call:
	child ident_or_ident_terminal, param_inst_list, arg_inst_list;

// A string of identifiers and operations chained together via the `.`
// (scope) operator.
IdentEtc, List:

NumExpr:
	initvar BigNum _n;
SizedNumExpr, NumExpr:
	child size;


// Blank brackets (`[]`) indicate that (a) this pair is on a port
// and (b) that this typename's generics or variable's dimensions are
// determined by what is connected to the port.
// For generics, it is different from when the brackets are left out
// entirely, as that indicates use of purely default values for the
// generics.  For arrays, it is not possible to have them without
// brackets.
// When there is no expression, it indicates that this bracket pair is
// blank.
BracketPair:
	// right is only used when this is a multi-bit slice
	child left, right;
ParenPair:

HasString:
	initvar string _s;

Ident, HasString:
ConstString, HasString:

ScopeBehav, List:

Enum:
	child the_typename, ident, scope, var_list;
ScopeEnum, List:

Class:
	initvar bool _packed;
	child ident, param_list, extends, scope, var_list;
ScopeClass, List:
Extends:
	initvar bool _is_virtual;
	child the_typename;

MemberCallable:
	initvar bool _is_const, _is_virtual, _is_static;
	child callable;

Union:
	child ident, scope, var_list;
ScopeUnion, List:

ParamPossibleTypename:
	child primary, param_inst_list;
NoParamPossibleTypename:
	child primary;
Typeof:
	child expr_or_typename;
TypeRange:
	child range_suffix;
RangeSuffix:

Auto: Void:
Uwire: Swire: Ubit: Sbit:
Ubyte: Sbyte: Ushortint: Sshortint:
Uint: Sint: Ulongint: Slongint:
Self:

PosParamArgInstList, List:
NamedParamArgInstList, List:
OneParamArgInst, LeftRightBase:

//// Expression parsing
//expr:
//	exprLogical
//	| exprLogical TokOpLogical expr 
//	;
//
//exprLogical:
//	exprCompare
//	| exprCompare TokOpCompare exprLogical 
//	;
//
//exprCompare:
//	exprAddSub
//	| exprAddSub TokPlus exprCompare
//	| exprAddSub TokMinus exprCompare
//	;
//
//exprAddSub:
//	exprMulDivModEtc
//	| exprMulDivModEtc TokOpMulDivMod exprAddSub
//	| exprMulDivModEtc TokOpBitwise exprAddSub
//	;
//
//exprMulDivModEtc:
//	exprPlusUnary
//	| exprMinusUnary
//	| exprLogNot
//	| exprBitNot
//	| exprCastUnsgn
//	| exprCastSgn
//	| exprClog2
//	//| exprPow
//	| numExpr
//	| identExpr
//	| '(' expr ')'
//	;

//// Expressions
//TokOpLogical: ('&&' | '||') ;
//TokOpCompare: ('==' | '!=' | '<' | '>' | '<=' | '>=') ;
//TokPlus: '+' ;
//TokMinus: '-' ;
//TokOpMulDivMod: ('*' | '/' | '%') ;
//TokOpBitwise: ('&' | '|' | '^' | '<<' | '>>' | '>>>') ;
//TokBitInvert: '~' ;

ExprBase:
	//noinitvar ExprValue value;
ExprBinopBase, ExprBase:
	child left, right;
ExprUnopBase, ExprBase:
	child child;

ExprBinopLogAnd, ExprBinopBase:
ExprBinopLogOr, ExprBinopBase:

ExprBinopCmpEq, ExprBinopBase:
ExprBinopCmpNe, ExprBinopBase:
ExprBinopCmpLt, ExprBinopBase:
ExprBinopCmpGt, ExprBinopBase:
ExprBinopCmpLe, ExprBinopBase:
ExprBinopCmpGe, ExprBinopBase:

ExprBinopPlus, ExprBinopBase:
ExprBinopMinus, ExprBinopBase:

ExprBinopMul, ExprBinopBase:
ExprBinopDiv, ExprBinopBase:
ExprBinopMod, ExprBinopBase:

ExprBinopBitAnd, ExprBinopBase:
ExprBinopBitOr, ExprBinopBase:
ExprBinopBitXor, ExprBinopBase:
ExprBinopBitLsl, ExprBinopBase:
ExprBinopBitLsr, ExprBinopBase:
ExprBinopBitAsr, ExprBinopBase:

ExprUnopLogNot, ExprUnopBase:
ExprUnopBitNot, ExprUnopBase:
ExprUnopPlus, ExprUnopBase:
ExprUnopMinus, ExprUnopBase:

ExprUnopDollarUnsigned, ExprUnopBase:
ExprUnopDollarSigned, ExprUnopBase:
ExprUnopDollarIsUnsigned, ExprUnopBase:
ExprUnopDollarIsSigned, ExprUnopBase:
ExprUnopDollarRange, ExprUnopBase:
ExprUnopDollarRevrange, ExprUnopBase:
ExprUnopDollarSize, ExprUnopBase:
ExprUnopDollarFirst, ExprUnopBase:
ExprUnopDollarLast, ExprUnopBase:
ExprUnopDollarHigh, ExprUnopBase:
ExprUnopDollarLow, ExprUnopBase:
ExprUnopDollarClog2, ExprUnopBase:

ExprBinopDollarPow, ExprBinopBase:

PseudoExprDollarBase:
	child child;
PseudoExprDollarPast, PseudoExprDollarBase:
PseudoExprDollarStable, PseudoExprDollarBase:
PseudoExprDollarRose, PseudoExprDollarBase:
PseudoExprDollarFell, PseudoExprDollarBase:
PseudoExprDollarGlobalClock:


ExprUnopTypeof, ExprUnopBase:
ExprCat, ExprBase:
	child list;
ListCat, List:

ExprRepl, ExprBase:
	child how_much_expr, to_repl_expr;

ExprRangeAny, ExprBase:
	child which_range;
RangeOne:
	child child;
RangeTwo, LeftRightBase:




StmtList, List:

StmtAnyFor:
	child var, items, scope;
StmtFor, StmtAnyFor:
StmtGenerateFor, StmtAnyFor:
	child label;

// generate if (...)
// {
// 	...
// }
// else generate if (...)
// {
// 	...
// }
//
// ...
//
// else generate
// {
// 	...
// }

StmtIf:
	child cond_expr, scope, stmt_else;

StmtGenerateIf, StmtIf:

StmtWhile:
	child cond_expr, scope;


StmtBehavAssign, LeftRightBase:
StmtContAssign, LeftRightBase:

StmtMemberAccessPublic:
StmtMemberAccessProtected:
StmtMemberAccessPrivate:

StmtSwitch:
	child expr, scope;
StmtSwitchz, StmtSwitch:
StmtCase:
	child expr, scope;
StmtDefault:
	child scope;
ScopeSwitch, List:

StmtUsing, LeftRightBase:

StmtInstModule:
	child module_ident, param_inst_list, inst_ident, arg_inst_list;
StmtReturn:
	child expr;
StmtInitial:
	child scope;
StmtAlwaysComb:
	child scope;
StmtAlwaysBlk:
	child edge_list, scope;
StmtAlwaysFf:
	child edge_list, scope;

StmtAssert:
	child expr;
StmtAssume:
	child expr;
StmtCover:
	child expr;
StmtRestrict:
	child expr;
StmtStaticAssert:
	child expr;

PosedgeInst:
	child expr;
NegedgeInst:
	child expr;
EdgeList, List:

DeclCallable:
	child param_list, arg_list, ident_or_op, scope;

DeclFunc, DeclCallable:
	child the_typename;
DeclProc, DeclCallable:
	initvar bool _is_port;
DeclTask, DeclCallable:

IdentTermEqualsExtra:
	child ident_terminal, extra;
IdentTermEqualsExtraList, List:

DeclConstList:
	child the_typename, ident_term_equals_extra_list;
DeclVarList, DeclConstList:
//DeclGenvar, DeclVar:
Modport, List:
	child ident;
ModportSubList:
	initvar string _port_dir;
	child ident_list;
IdentList, List:
