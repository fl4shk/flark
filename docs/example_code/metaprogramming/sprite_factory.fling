class Vec2f
{
	x, y: float = 0;
	default func init[(), (@const ...), (@@...),
		(to_copy: @const self_t), (to_move: @@self_t)];
	default func dest();

	//default func "="[(to_copy: @const self_t), (to_move: @@self_t)]: @auto;

	gen for item in ["+", "-"]
	{
		const func item(other: @const self_t) =>
			self_t(x: self.x.item(other.x), y: self.y.item(other.y))
	}
	gen for item in ["*", "/"]
	{
		const func item(scale: float) =>
			self_t(x: self.x.item(scale), y: self.y.item(scale))
	}

	gen for item in ["+=", "-=", "*=", "/="]
	{
		default func item(@const ...): @self_t;
	}
}

class CollBox
{
	priv #[crget, crset]# _pos, _size: Vec2f;
	default func init[(), (@const ...), (@@...),
		(to_copy: @const self_t), (to_move: @@self_t)];
	default func dest();

	const func x() => self._pos.x
	func set_x(x: float): void => self._pos.x = x

	const func y() => self._pos.y
	func set_y((y: float): void => self._pos.y = y

	const func width() => self._size.x
	func set_width(width: float): void => self._size.x = width

	const func height() => self._size.y
	func set_height(height: float): void => self._size.y = height
}

base class #[rtident<u16>]# Sprite
{
	using State = i32;

	priv #[crget, prot_crset]# _pos, _vel, _acc: Vec2f;
	priv #[crget, prot_crset]# _cb: CollBox;
	//priv #[vget, vset]# _index: i32;
	prot #[crget]# _state: State[8];

	func init()
	{
		for item in self._state =>
			item = 0;
	}
	default func init(to_copy: @const self_t);
	default dyn func dest();

	const func x() => self.pos().x
	func set_x(x: float): void => self._pos.x = x

	// collision box x is relative to self.x
	const func phys_x() => self.x() + self.cb().x()

	const func y() => self.pos().y
	func set_y(y: float): void => self._pos.y = y

	// collision box y is relative to self.y
	const func phys_y() => self.y() + self.c().y()

	const func vel_x() => self.vel().x
	func set_vel_x(vel_x: float): void => self._vel.x = vel_x

	const func vel_y() => self.vel().y
	func set_vel_y(vel_y: float): void => self._vel.y = vel_y

	const func acc_x() => self.acc().x
	func set_acc_x(acc_x: float): void => self._acc.x = acc_x

	const func acc_y() => self.acc().y
	func set_acc_y(acc_y: float): void => self._acc.y = acc_y


	//const dyn func ident() => @tokstrm(self_t).name();

	dyn func behav(): void {}
	prot func _update_vel(): void =>
		self.set_vel(self.vel() + self.acc())
	prot func _update_pos(): void =>
		self.set_pos(self.pos() + self.vel())
}

// When pigs fly!
base class #[rtident<u16>]# PigWithWings extends Sprite
{
	func init()
	{
		self._st_fly_counter() = 0;
		self.set_vel_y(-1);
		self.set_cb(CollBox(pos: Vec2f(x: 0, y: 0),
			size: Vec2f(x: 16, y: 16)));
	}
	default func init(to_copy: @const self_t);
	default dyn func dest();

	prot func _st_fly_counter(): @State => self._state[0]

	//const dyn func ident() => tokstrm(self_t).name()

	static MAX_FLY_COUNTER: const State = 20;

	dyn func behav(): void
	{
		if self._st_fly_counter() >= MAX_FLY_COUNTER =>
			self.set_vel_y(self.vel_y() * -1);
		else =>
			self._st_fly_counter() += 1;
		self._update_pos();
	}
}

// How many engineers does it take to screw in a lightbulb?  One.
base class #[rtident<u16>]# EngineerWithLightbulb extends Sprite
{
	// encoded as a State
	prot enum BhvState: State
	{
		Search;
		ClimbLadder;
		ScrewIn;
	}

	func init()
	{
		self._st_bhv_state() = BhvState::Search as State;
		self._st_counter() = 0;
		self.set_cb(CollBox(Vec2f(0, 0), Vec2f(16, 32)));
	}
	default func init(to_copy: @const self_t);
	default dyn func dest();

	static (MAX_SEARCH_COUNTER, MAX_CLIMB_LADDER_COUNTER
		MAX_SCREW_IN_COUNTER): const State = (60, 30, 20);

	gen
	{
		local gen state_func_list: const [string...] = ["_st_bhv_state",
			"_st_counter"];
		gen for i in range(state_func_list) =>
			prot func #(state_func_list[i])(): @State => self._state[i]
	}

	dyn func behav(): void
	{
		match self._st_bhv_state() as BhvState
		{
		Search =>
			if self._st_counter() >= MAX_SEARCH_COUNTER
			{
				self._st_counter() = 0;
				self._st_bhv_state() = BhvState::ClimbLadder as State;
			}
			else =>
				self._st_counter() += 1;
		ClimbLadder =>
			if self._st_counter() >= MAX_CLIMB_LADDER_COUNTER
			{
				self._st_counter() = 0;
				self._st_bhv_state() = BhvState::ScrewIn as State;
			}
			else =>
				self._st_counter() += 1;
		ScrewIn =>
			if self._st_counter() >= MAX_SCREW_IN_COUNTER
			{
				self._st_counter() = 0;
				self._st_bhv_state() = BhvState::Search as State;
			}
			else =>
				self._st_counter() += 1;
		}
	}
}

trait IsInteger<T: type> requires => T.related_to<size_t>()
trait IsSigned<T: type> requires => (((-1) as T) < (0 as T))
trait IsSignedInteger<T: type> = IsInteger<T> && IsSigned<T>;
trait IsUnsignedInteger<T: type> = IsInteger<T> && (!IsSigned<T>);

base class Stack<T: type, IndexT: type(IsUnsignedInteger)=size_t>
{
	prot #[crget]# _vec: std::vector<T>;
	prot #[vget]# _top_index: IndexT = -1 as IndexT;

	default func init[(), (to_copy: @const self_t), (to_move: @@self_t)];
	default dyn func dest();

	using ExcValue = (stack: @self_t);

	prot variant Exception
	{
		NothingInStack(ExcValue);
		TooManyPops(ExcValue);
	}

	gen for item in ["cp", "mv"]
	{
		// `local` indicates that the item is local to the current instance
		// of code generation
		local using ToPushT 
			= gen type if item == "cp" => @const T
			else gen type => @@T;

		func push(to_push: ToPushT): result<IndexT, auto>
		{
			local define `modded_to_push =>
				gen if item == "cp" => to_push
				else gen => move(to_push)

			if self._top_index < self._vec.size()
			{
				self._vec[self._top_index] = `modded_to_push;
			}
			else
			{
				self._vec.push_back(`modded_to_push);
			}
			Ok(self._top_index += 1 as IndexT)
		}
	}
	func top[const (): result<@const T, Exception>,
		(): result<@T, Exception>] =>
		if self._top_index == 0 => Err(NothingInStack(self))
		else => Ok(self._vec[self._top_index])

	func pop(): result<IndexT, Exception> =>
		if self._top_index == 0 => Err(TooManyPops(self))
		else => Ok(self._top_index -= 1)
}

class SpriteFactory<IndexT: type(IsSignedInteger)=i32>
{
	using VecDataT = u8[sizeof(Sprite)];
	priv #[crget]# _vec: std::vector<VecDataT>;
	priv #[crget]# _stack: Stack<IndexT>;

	default func init[(), (to_copy: @const self_t), (to_move: @@self_t)];
	default func dest();

}
