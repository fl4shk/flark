class Vec2f
{
	x, y: float = 0;
	default func init[(), (@const ...), (@@...),
		(to_copy: @const self_t), (to_move: @@self_t)];
	default func dest();

	default func "="[(to_copy: @const self_t), (to_move: @@self_t)]: @auto;

	gen for item in ["+", "-"]
	{
		const func item(other: @const self_t) =>
			self_t(x: self.x.item(other.x), y: self.y.item(other.y));
	}
	gen for item in ["*", "/"]
	{
		const func item(scale: float) =>
			self_t(x: self.x.item(scale), y: self.y.item(scale));
	}

	gen for item in ["+=", "-=", "*=", "/="]
	{
		default func item(@const ...): @self_t;
	}
}

class CollBox
{
	priv #[crget, crset]# _pos, _size: Vec2f;
	default func init[(), (@const ...), (@@...),
		(to_copy: @const self_t), (to_move: @@self_t)];
	default func dest();

	const func x() => self._pos.x;
	func set_x(x: float): void => self._pos.x = x;

	const func y() => self._pos.y;
	func set_y((y: float): void => self._pos.y = y;

	const func width() => self._size.x;
	func set_width(width: float): void => self._size.x = width;

	const func height() => self._size.y;
	func set_height(height: float): void => self._size.y = height;
}

base class #[rtident(u16)]# Sprite
{
	using State = i32;

	priv #[crget, prot_crset]# _pos, _vel, _acc: Vec2f;
	priv #[crget, prot_crset]# _cb: CollBox;
	prot #[crget]# _state: State[8];

	func init()
	{
		for item in self._state
		{
			item = 0;
		}
	}
	default func init(to_copy: @const self_t);
	default dyn func dest();

	const func x() => self.pos().x;
	func set_x(x: float): void => self._pos.x = x;
	const func phys_x() => self.x() + self.cb().x();

	const func y() => self.pos().y;
	func set_y(y: float): void => self._pos.y = y;
	const func phys_y() => self.y() + self.c().y();

	const func vel_x() => self.vel().x;
	func set_vel_x(vel_x: float): void => self._vel.x = vel_x;

	const func vel_y() => self.vel().y;
	func set_vel_y(vel_y: float): void => self._vel.y = vel_y;

	const func acc_x() => self.acc().x;
	func set_acc_x(acc_x: float): void => self._acc.x = acc_x;

	const func acc_y() => self.acc().y;
	func set_acc_y(acc_y: float): void => self._acc.y = acc_y;


	//const dyn func ident() => @tokstrm(self_t).name();

	dyn func behav(): void {}
	prot func _update_vel(): void =>
		self.set_vel(self.vel() + self.acc());
	prot func _update_pos(): void =>
		self.set_pos(self.pos() + self.vel());
}

// When pigs fly!
base class #[rtident(u16)]# PigWithWings extends Sprite
{
	func init()
	{
		self._st_fly_counter() = 0;
		self.set_vel_y(-1);
		self.set_cb(CollBox(pos: Vec2f(x: 0, y: 0),
			size: Vec2f(x: 16, y: 16)));
	}
	default func init(to_copy: @const self_t);
	default dyn func dest();

	prot func _st_fly_counter(): @self_t::State => self._state[0];

	//const dyn func ident() => tokstrm(self_t).name();

	static MAX_FLY_COUNTER: const self.State = 20;

	dyn func behav(): void
	{
		if self._st_fly_counter() >= self.MAX_FLY_COUNTER
		{
			self.set_vel_y(self.vel_y() * -1);
		}
		else
		{
			self._st_fly_counter() += 1;
		}
		self._update_pos();
	}
}

// How many engineers does it take to screw in a lightbulb?  One.
base class #[rtident(u16)]# EngineerWithLightbulb extends Sprite
{
	// encoded as a self.State
	prot enum BhvState : self.State
	{
		Search,
		ClimbLadder,
		ScrewIn,
	}

	func init()
	{
		self._st_bhv_state() = BhvState::Search as self.State;
		self._st_counter() = 0;
		self.set_cb(CollBox(Vec2f(0, 0), Vec2f(16, 32)));
	}
	default func init(to_copy: @const self_t);
	default dyn func dest();

	static (MAX_SEARCH_COUNTER, MAX_CLIMB_LADDER_COUNTER
		MAX_SCREW_IN_COUNTER): const self.State = (60, 30, 20);

	gen const state_func_list := ["_st_bhv_state", "_st_counter"];
	gen for i in range(state_func_list)
	{
		prot func #(state_func_list[i])(): @self.State => self._state[i];
	}

	dyn func behav(): void
	{
		match self._st_bhv_state() as self.BhvState
		{
			Search
			{
				if self._st_counter() >= self.MAX_SEARCH_COUNTER
				{
					self._st_counter() = 0;
					self._st_bhv_state() = self.BhvState::ClimbLadder
						as self.State;
				}
				else
				{
					self._st_counter() += 1;
				}
			}
			ClimbLadder
			{
				if self._st_counter() >= self.MAX_CLIMB_LADDER_COUNTER
				{
					self._st_counter() = 0;
					self._st_bhv_state() = self.BhvState::ScrewIn
						as self.State;
				}
				else
				{
					self._st_counter() += 1;
				}
			}
			ScrewIn
			{
				if self._st_counter() >= self.MAX_SCREW_IN_COUNTER
				{
					self._st_counter() = 0;
					self._st_bhv_state() = self.BhvState::Search
						as self.State;
				}
				else
				{
					self._st_counter() += 1;
				}
			}
		}
	}
}

class SpriteFactory
{
	// Tuples
	//using SprAndIndex = (index: i32, sprite: Sprite);
	//using ArrElem = (stk_index: i32, spr_and_index: SprAndIndex,
	//	sai_ptr: *SprAndIndex);
	//priv _arr: ArrElem[size];

	priv _spr_vec: std::vector<(index: i32, sprite: Sprite)>;
	priv _top: i32;

	func init()
	{
		for i: size_t in range(self._arr)
		{
			self._arr[i].stk_index = i;
			self._arr[i].spr_and_index = SprAndIndex(index: i,
				sprite: Sprite());
			self._arr[i].sai_ptr = null;
		}
		self._top = self.size - 1;
	}
	default func dest();

	func build(id: u16
}
