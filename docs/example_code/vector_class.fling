base class vector[T: type]
{
// iterators
	class iterator[rvs: bool=false] extends ::iterator
	{
		vec: *vector; 
		where: size_t;

		func "init"() = default;
		func "var_init"(...) = default;
		func "init"(iter: @const iterator) = default;

		func "cmp"(iter: @const iterator): cmp_t
		{
			gen if !self.rvs
			{
				if self.where < vec*.size()
			}
			else gen // if self.rvs
			{
			}
		}
	}

	const func "fwditer"(): iterpair[iterator[false]]
	{
	}
	const func "rvsiter"(): iterator[false]
	{
	}
	const func "range"()
	{
		return range(self.size());
	}

// member variables
	priv #[pub_vget] _size, _capacity: size_t = 0;
	priv _data: std::unique_ptr[T, true];
	const func data(): *T
	{
		return self._data.get();
	}

// functions
	func "init"()
	{
		self._data.reset(null);
	}
	func "init"(size: size_t)
	[
		self._size(size),
		self._capacity(size)
	]
	{
		// Propagate errors. (braces not needed for just one statement)
		try self._data.reset(new T[self.capacity()]);
	}
	func "init"(to_copy: @const vector)
	[
		try self."init"(to_copy.capacity()),
	]
	{
		// Deep copy
		for i in range(self)
		{
			self._data[i] = to_copy._data[i];
		}
	}
	func "init"(to_move: @@vector) = default;
	func "dest"() = default;

}
