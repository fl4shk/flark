class Vec2f
{
	x, y: float = 0;
	default func init[(), (@const ...), (@@...),
		(to_copy: @const self_t), (to_move: @@self_t)];
	default func dest();

	//default func "="[(to_copy: @const self_t), (to_move: @@self_t)]: @auto;

	gen for item in ["+", "-"]
	{
		const func item(other: @const self_t) =>
			self_t(x: self.x.item(other.x), y: self.y.item(other.y))
	}
	gen for item in ["*", "/"]
	{
		const func item(scale: float) =>
			self_t(x: self.x.item(scale), y: self.y.item(scale))
	}

	gen for item in ["+=", "-=", "*=", "/="]
	{
		default func item(@const ...): @self_t;
	}
}

class CollBox
{
	priv #[crget, crset]# _pos, _size: Vec2f;
	default func init[(), (@const ...), (@@...),
		(to_copy: @const self_t), (to_move: @@self_t)];
	default func dest();

	const func x() => self._pos.x
	func set_x(x: float): void => self._pos.x = x

	const func y() => self._pos.y
	func set_y((y: float): void => self._pos.y = y

	const func width() => self._size.x
	func set_width(width: float): void => self._size.x = width

	const func height() => self._size.y
	func set_height(height: float): void => self._size.y = height
}

// The #[vident<u16>]# attribute will be inherited by all derived classes
base class #[vident<u16>]# Sprite
{
	prot using State = i32;

	priv #[crget, prot_crset]# _pos, _vel, _acc: Vec2f;
	priv #[crget, prot_crset]# _cb: CollBox;
	//priv #[vget, vset]# _index: i32;
	prot #[crget]# _state: State[8];

	func init()
	{
		for item in self._state => item = 0;
	}
	default func init(to_copy: @const self_t);
	default dyn func dest();

	const func x() => self.pos().x
	func set_x(x: float): void => self._pos.x = x

	// collision box x is relative to self.x
	const func phys_x() => self.x() + self.cb().x()

	const func y() => self.pos().y
	func set_y(y: float): void => self._pos.y = y

	// collision box y is relative to self.y
	const func phys_y() => self.y() + self.c().y()

	const func vel_x() => self.vel().x
	func set_vel_x(vel_x: float): void => self._vel.x = vel_x

	const func vel_y() => self.vel().y
	func set_vel_y(vel_y: float): void => self._vel.y = vel_y

	const func acc_x() => self.acc().x
	func set_acc_x(acc_x: float): void => self._acc.x = acc_x

	const func acc_y() => self.acc().y
	func set_acc_y(acc_y: float): void => self._acc.y = acc_y


	//const dyn func ident() => @tokstrm(self_t).name();

	dyn func behav(): void {}
	prot func _update_vel(): void =>
		self.set_vel(self.vel() + self.acc())
	prot func _update_pos(): void =>
		self.set_pos(self.pos() + self.vel())
}

// When pigs fly!
base class PigWithWings extends Sprite
{
	func init()
	{
		self._st_fly_counter() = 0;
		self.set_vel_y(-1);
		self.set_cb(CollBox(pos: Vec2f(x: 0, y: 0),
			size: Vec2f(x: 16, y: 16)));
	}
	default func init(to_copy: @const self_t);
	default dyn func dest();

	prot func _st_fly_counter(): @State => self._state[0]

	//const dyn func ident() => tokstrm(self_t).name()

	prot static MAX_FLY_COUNTER: const State = 20;

	dyn func behav(): void
	{
		if self._st_fly_counter() >= MAX_FLY_COUNTER
		{
			self.set_vel_y(self.vel_y() * -1);
		}
		else
		{
			self._st_fly_counter() += 1;
		}
		self._update_pos();
	}
}

// How many engineers does it take to screw in a lightbulb?  One.
base class EngineerWithLightbulb extends Sprite
{
	// encoded as a State
	prot enum BhvState: State
	{
		Search;
		ClimbLadder;
		ScrewIn;
	}

	func init()
	{
		self._st_bhv_state() = BhvState::Search as State;
		self._st_counter() = 0;
		self.set_cb(CollBox(Vec2f(0, 0), Vec2f(16, 32)));
	}
	default func init(to_copy: @const self_t);
	default dyn func dest();

	static (MAX_SEARCH_COUNTER, MAX_CLIMB_LADDER_COUNTER
		MAX_SCREW_IN_COUNTER): const State = (60, 30, 20);

	gen
	{
		local gen state_func_list: const [string...] = ["_st_bhv_state",
			"_st_counter"];
		gen for i in range(state_func_list)
		{
			prot func #(state_func_list[i])(): @State => self._state[i]
		}
	}

	dyn func behav(): void
	{
		match self._st_bhv_state() as BhvState
		{
			Search
			{
				if self._st_counter() >= MAX_SEARCH_COUNTER
				{
					self._st_counter() = 0;
					self._st_bhv_state() = BhvState::ClimbLadder as State;
				}
				else => self._st_counter() += 1;
			}
			ClimbLadder
			{
				if self._st_counter() >= MAX_CLIMB_LADDER_COUNTER
				{
					self._st_counter() = 0;
					self._st_bhv_state() = BhvState::ScrewIn as State;
				}
				else => self._st_counter() += 1;
			}
			ScrewIn
			{
				if self._st_counter() >= MAX_SCREW_IN_COUNTER
				{
					self._st_counter() = 0;
					self._st_bhv_state() = BhvState::Search as State;
				}
				else => self._st_counter() += 1;
			}
		}
	}
}

trait IsInteger<T: type> requires => T.related_to<size_t>()
trait IsSigned<T: type> requires => (((-1) as T) < (0 as T))
trait IsSignedInteger<T: type> = IsInteger<T> && IsSigned<T>;
trait IsUnsignedInteger<T: type> = IsInteger<T> && (!IsSigned<T>);

base class Stack<T: type, IndexT: type(IsUnsignedInteger)=size_t>
{
	prot #[crget]# _vec: std::vector<T>;
	prot #[vget]# _top_index: IndexT = -1 as IndexT;

	default func init[(), (to_copy: @const self_t), (to_move: @@self_t)];
	default dyn func dest();

	variant Exception
	{
		NothingInStack(@self_t);
		TooManyPops(@self_t);
	}

	gen for item in ["cp", "mv"]
	{
		// `local` indicates that the item is local to the current instance
		// of code generation
		local using ToPushT 
			= gen type if item == "cp" => @const T
			else gen type => @@T;

		func push(to_push: ToPushT): result<IndexT, variant<auto...>>
		{
			local define `modded_to_push() =>
				gen if item == "cp" => to_push
				else gen => move(to_push)

			if self._top_index < self._vec.size()
			{
				self._vec[self._top_index] = `modded_to_push();
			}
			else
			{
				self._vec.push_back(`modded_to_push())?;
			}
			Ok(self._top_index += 1 as IndexT)
		}
	}
	func top[const (): result<@const T, Exception>,
		(): result<@T, Exception>] =>
		if self._top_index == 0 => Err(NothingInStack(self))
		else => Ok(self._vec[self._top_index])

	const func size() =>
		self._vec.size()


	func pop(): result<IndexT, Exception> =>
		if self._top_index == 0 => Err(TooManyPops(self))
		else => Ok(self._top_index -= 1)
}

base class Factory<T: type, IndexT: type(IsSignedInteger)=i32>
{
	using ToAllocT = (active: bool, arr: array<u8, sizeof(T)>);
	prot #[crget]# _vec: std::vector<ToAllocT>;
	prot #[crget]# _stk: Stack<IndexT>;

	default func[init[(), (to_copy: @const self_t), (to_move: @@self_t)],
		dyn dest()];

	variant Exception
	{
		InvalidTypeIndex(@self_t);
		UnallocatedIndex(@self_t);
	}

	// This is a compile-time hash table.  It maps `u16`s
	// (`T::VidentT`'s) to `type`s
	gen typ_map: [T::VidentT: type];

	// Create a code generation scope.
	gen
	{
		local gen func build_typ_map(ts: @const tokstrm): result<cmp_t,
			string>
		{
			const vident := ts.typename()::init().vident();

			if !gen<typ_map>.holds(vident)
			{
				gen<typ_map>[vident] = ts.typename()::init();
				for inner_ts in ts.extends_list()
				{
					gen<build_typ_map>(inner_ts)?
				}
				Ok(0 as cmp_t)
			}
			else => Err("Duplicate vident in inheritance hierarchy")
		}
		gen try => gen<build_typ_map>(tokstrm(T))?;
		gen catch s => static_assert(false, gen<s>);
	}

	func alloc(id: T::VidentT): result<IndexT, variant{type...}>
	{
		match id
		{
			gen for pair in gen<typ_map>
			{
				gen<pair>[0]
				{
					if (self._stk.top() < 0) ||
						(self._stk.top() >= (self._vec.size() - 1))
					{
						to_push: ToAllocT;
						for item in to_push.data => item = 0 as u8;

						self._vec.push_back(to_push)?;
						self._stk.push(self._vec.size() - 1)?;
					}
					// The top of the stack is outside of
					// already-allocated space in the vector

					const ret := self._stk.pop()?;

					// Assume we're inside the vector (this is definitely
					// the case if this class has correct code).
					// `?` applied to `gen<pair>[1]()` only takes effect if
					// `pair[1]()` can actually return something that
					// has the `?` operator defined for it.
					self._vec[ret].active = true;
					new (self._vec[ret].arr.data()) gen<pair>[1]()?;
					Ok(ret)
				}
			}
			default => Err(Exception::InvalidTypeIndex(self))
		}
	}
	func dealloc(id: T::VidentT): option<variant{type...}>
	{
		if !self._vec.at(id)?.active
		{
			Some(Exception::UnallocatedIndex(self))
		}
		self._vec[id].active = false;
		reinterpret<*T>(self._vec[id].arr.data())->dest();
		None
	}
}

class SpriteFactory<IndexT: type(IsSignedInteger)=i32>
	extends Factory<Sprite, IndexT>
{
	default func[init[(), (to_copy: @const self_t), (to_move: @@self_t)],
		dest()];
}
