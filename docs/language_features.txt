variants and tuples as built-in things (for `match`)

A bunch of built-in attributes especially intended for guiding the compiler
in optimization.


traits:  definitely different syntax from C++20 concepts, usable like Rust
traits.  C++20 concepts are an inspiration in that a trait can be in the
form of a compile-time expression.

Traits can be used for runtime polymorphism only when they are class-like
and contain only function definitions and/or static members (of any type).

Regular trait constraint:

class UnsgnVec[Type: type: UnsgnInt] extends vector[Type]

Higher kinded trait constraint:


OOP similar to typical C++ but with somewhat different syntax.  They
require `pub`, `prot`, or `priv` in front of every declaration. 


parameter packs:  compile-time lists that you can pass to functions such
that they expand to comma-separated lists.  You can only manipulate these
lists at compile-time, and they still use C++-ish `...` syntax.  At
compile-time they act a lot like Python `*args` and `**kwargs`.

Parameter pack initialization is similar to array initialization:

let x: int... = [1, 2, 3];

let x: int[3] = [1, 2, 3];

let x: int[] = [1, 2, 3];


Parameter packs can be implicitly converted to arrays in both
initialization and in assigning to the whole array or to a slice of the
array.  This is not permitted when the size of the array is not known until
the middle end or until the C compiler is involved.


Interpreted form of the language available at compile-time for the purposes
of both code generation and compile-time code execution.  This is the way
you use parameter packs.  This interpreted form of the language is also
available as just a regular way to use the language itself.


Build system that is part of the language itself but that must exist in
files separate from what library is being compiled.  Thus, no build
instructions should be placed into the code you are compiling.


Libraries as part of the language itself.  All code exists in a library of
some sort.

Foreign language code is supported, but it must have `extern` definitions.


C interop is available only via C code generation.

Inline assembly can be generated by user source code due to the use of
compile-time strings, but it is not supported in interpreter or C interop
mode.
