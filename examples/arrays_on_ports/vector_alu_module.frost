package PkgAlu
{
	//enum bitu [3] Opcode
	// This syntax indicates that this `enum` is as small as it can be
	// while still fitting everything.
	enum Opcode
	{
		Add,
		Adc,
		Sub,
		Sbc,

		And,
		Or,
		Xor,
		Nor,
	};

	class Bus[intu WIDTH]
		//extends AluPorts[.WIDTH(WIDTH)]
	{
		using DataInout = bitu[WIDTH];
		//using DataInout = bitu[WIDTH - 1:0];

		packed class BusIn
		{
			bitu carry;
			DataInout a, b;
			Opcode opcode;
		} in;

		packed class BusOut
		{
			bitu carry;
			DataInout data;
		} out;

		// Function object
		// Operator overloading syntax is similar to that of VHDL, so that
		// means that "()" is the operator being overloaded.
		const func BusOut "()" ()
		{
			using Opcode;

			switch (in.opcode)
			{
			case Add:
				return cat(1'0b0, in.a) + cat(1'0b0, in.b);
			case Adc:
				return cat(1'0b0, in.a) + cat(1'0b0, in.b) + in.carry;
			case Sub:
				return cat(1'0b0, in.a) + cat(1'0b0, ~in.b) + 1'0b1;
			case Sbc:
				return cat(1'0b0, in.a) + cat(1'0b0, ~in.b) + in.carry;

			case And:
				return cat(1'0b0, (in.a & in.b));
			case Or:
				return cat(1'0b0, (in.a | in.b));
			case Xor:
				return cat(1'0b0, (in.a ^ in.b));
			case Nor:
				return cat(1'0b0, ~(in.a | in.b));
			}
		}

		// These are processes
		proc compute()
		{
			assign out = self();
		}

		proc to_extern
		(
			input
				bitu i_carry,
				DataInout i_a, i_b,
				Opcode i_opcode,

			output
				bitu o_carry,
				DataInout o_data,
		)
		{
			// How this will be compiled is as follows.
			// `input` ports cannot be written to.
			// `output` ports can be read from and written to.
			// `bidir` ports can be read from and written to.
			// The semantics are identical to `module` ports, but in the
			// generated Verilog, everything will be inlined without
			// creation of any new `module`s.
			// Recursion is possible, but must have a depth that is
			// identified at compile time.
			// There are not really any other constraints.
			assign in = cat(i_carry, i_a, i_b, i_opcode);
			assign cat(o_carry, o_data) = out;
		}
	};
}

module Alu[intu WIDTH]
(
	input
		bitu i_carry,
		bitu[WIDTH] i_a, i_b,
		Opcode i_opcode,

	output
		bitu o_carry,
		bitu[WIDTH] o_data,
)
{
	using PkgAlu;
	Bus[.WIDTH] bus;

	bus.to_extern(.i_carry, .i_a, .i_b, .i_opcode,
		.o_carry, .o_data);

	inst Alu(.bus);
	// Alternatively, one can do this to get the same result:
	// bus.compute();
}

module Alu[intu WIDTH]
(
	bidir PkgAlu::Bus[.WIDTH] bus,
)
{
	bus.compute();
}

module Alu
(
	// This syntax means that the `class` placed on the bus of an
	// instance of this `Alu` can be determined by the instantiation of
	// this `Alu`.
	bidir PkgAlu::Bus[] bus,
)
{
	//assign cat(bus.out.carry, bus.out.data) = bus();
	bus.compute();
}

module VectorAlu[intu ALU_WIDTH, ARR_SIZE]
(
	input
		DataInout i_a_arr[ARR_SIZE], i_b_arr[ARR_SIZE],
		bitu i_carry_arr[ARR_SIZE],
		PkgAlu::Opcode i_opcode_arr[ARR_SIZE],

	output
		DataInout o_data_arr[ARR_SIZE],
		bitu o_carry_arr[ARR_SIZE],
)
{
	using DataInout = bitu[ALU_WIDTH];
	//generate lab for (i : ports_arr$range)
	// The label is optional, but you won't be able to access the insides
	// from outside without it.
	generate for (i : range(ARR_SIZE))
	{
		inst Alu[.WIDTH(ALU_WIDTH)]

		// This identifier is optional because it is totally unnecessary in
		// most cases.  Of course, a name is required in the generated
		// Verilog.
		alu
		(
			.i_a(i_a_arr[i]), .i_b(i_b_arr[i]),
			.i_carry(i_carry_arr[i]),
			.i_opcode(i_opcode_arr[i]),

			.o_data(o_data_arr[i]),
			.o_carry(o_carry_arr[i]),
		);
	}
}

module VectorAlu
(
	bidir PkgAlu::Bus[] bus_arr[],
)
{
	//generate lab for (i : bus_arr$range)
	generate lab for (bus : bus_arr)
	{
		//inst Alu alu(.bus(bus_arr[i]));
		inst Alu(.bus(bus));
	}
}
