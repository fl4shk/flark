//module FullAdder(input logic i_a, i_b, i_carry,
//	output logic o_sum, o_carry)
//{
//	assign o_sum = (i_a ^ i_b) ^ i_carry;
//	assign o_carry = (i_a & i_b) | ((i_a ^ i_b) & i_carry);
//}

module RippleCarryAdder
	// "DIO" is short for "data input/output"
	#(
		WIDTH__DIO=4
	)
	(
		input logic [WIDTH__DIO] i_a, i_b,
		input logic i_carry,
		output logic [WIDTH__DIO] o_sum,
		output logic o_carry
	)
{
	localparam _WIDTH__INNER_CARRIES = WIDTH__DIO + 1;

	logic [_WIDTH__INNER_CARRIES] _inner_carries;


	//// What I want to be able to do:
	//assign concat($first(_inner_carries), o_carry)
	//	= concat(i_carry, $last(_inner_carries));
	//
	//generate for (i : range(WIDTH__DIO))
	////generate for (i : range($size(o_sum)))
	//{
	//	// With no way to access the insides of a "module" (other than via
	//	// ports), there is no point to giving names to "module" instances.
	//	// Thus, this language will NOT have names of "module" instances.
	//	// It also helps to make the grammar cleaner.
	//	instance FullAdder
	//	(
	//		i_a(i_a[i]),
	//		i_b(i_b[i]),
	//		i_carry(_inner_carries[i]),
	//		o_sum(o_sum[i]),
	//		o_carry(_inner_carries[i + 1])
	//	);
	//}

	// What I'm doing until more of the languages is implemented:
	assign _inner_carries[0] = i_carry;
	assign o_carry = _inner_carries[_WIDTH__INNER_CARRIES - 1];

	// I have split up the two "generate" loops to make sure that multiple
	// "generate" loops get processed correctly.  I should also test the
	// case where the "assign"s are both in the same "generate" loop.
	generate for (i : range(WIDTH__DIO))
	{
		assign o_sum[i] = (i_a[i] ^ i_b[i]) ^ _inner_carries[i];
	}

	generate for (i : range(WIDTH__DIO))
	{
		assign _inner_carries[i + 1] = (i_a[i] & i_b[i])
			| ((i_a[i] ^ i_b[i]) & _inner_carries[i]);
	}
}
